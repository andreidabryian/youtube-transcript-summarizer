using Microsoft.Extensions.Logging;
using YoutubeExplode;
using YoutubeExplode.Videos;
using YoutubeExplode.Videos.ClosedCaptions;
using YouTubeTranscriptSummarizer.Core.Interfaces;
using YouTubeTranscriptSummarizer.Core.Models;

namespace YouTubeTranscriptSummarizer.Services.Services;

public class YouTubeService : IYouTubeService
{
    private readonly YoutubeClient _youtubeClient;
    private readonly ILogger<YouTubeService> _logger;

    public YouTubeService(ILogger<YouTubeService> logger)
    {
        _youtubeClient = new YoutubeClient();
        _logger = logger;
    }

    public async Task<VideoInfo> GetVideoInfoAsync(string videoUrl)
    {
        try
        {
            var videoId = VideoId.Parse(videoUrl.Trim());
            var video = await _youtubeClient.Videos.GetAsync(videoId);

            return new VideoInfo
            {
                Id = video.Id.Value,
                Title = video.Title,
                Author = video.Author.ChannelTitle,
                Duration = video.Duration ?? TimeSpan.Zero,
                Description = video.Description,
                ThumbnailUrl = video.Thumbnails.FirstOrDefault()?.Url ?? string.Empty,
                UploadDate = video.UploadDate.DateTime,
                ViewCount = 0 // Statistics are not available in the current API version
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Ошибка при получении информации о видео: {VideoUrl}", videoUrl);
            throw new InvalidOperationException($"Не удалось получить информацию о видео: {ex.Message}");
        }
    }

    public async Task<VideoTranscript> GetTranscriptAsync(string videoUrl)
    {
        try
        {
            var videoId = VideoId.Parse(videoUrl.Trim());
            var video = await _youtubeClient.Videos.GetAsync(videoId);
            var videoInfo = await GetVideoInfoAsync(videoUrl);

            var trackManifest = await _youtubeClient.Videos.ClosedCaptions.GetManifestAsync(videoId);
            var track = trackManifest.Tracks.FirstOrDefault(t => t.Language.Code == "ru") 
                       ?? trackManifest.Tracks.FirstOrDefault(t => t.Language.Code == "en")
                       ?? trackManifest.Tracks.FirstOrDefault();

            if (track == null)
            {
                throw new InvalidOperationException("Транскрипция недоступна для данного видео");
            }

            var captions = await _youtubeClient.Videos.ClosedCaptions.GetAsync(track);

            var segments = captions.Captions.Select(caption => new TranscriptSegment
            {
                Start = caption.Offset,
                End = caption.Offset + caption.Duration,
                Text = caption.Text
            }).ToList();

            return new VideoTranscript
            {
                VideoInfo = videoInfo,
                Segments = segments
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Ошибка при получении транскрипции: {VideoUrl}", videoUrl);
            throw new InvalidOperationException($"Не удалось получить транскрипцию: {ex.Message}");
        }
    }

    public async Task<bool> HasTranscriptAsync(string videoUrl)
    {
        try
        {
            var videoId = VideoId.Parse(videoUrl.Trim());
            var trackManifest = await _youtubeClient.Videos.ClosedCaptions.GetManifestAsync(videoId);
            _logger.LogInformation("Получено {Count} треков субтитров для {VideoUrl}", trackManifest.Tracks.Count, videoUrl);
            foreach (var track in trackManifest.Tracks)
            {
                _logger.LogInformation("Track: {Lang} (Auto: {Auto}) - {Url}", track.Language.Name, track.IsAutoGenerated, track.Url);
            }
            return trackManifest.Tracks.Any();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Ошибка при проверке наличия транскрипции: {VideoUrl}", videoUrl);
            throw;
        }
    }
} 